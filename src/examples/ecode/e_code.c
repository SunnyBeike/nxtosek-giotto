/* This file was generated by GiottoC: http://www.eecs.berkeley.edu/~fresco/giotto */

#include "e_code.h"

instruction_type program[MAXPROGRAM] = {
/* 0 */  CALL(3)          /* Call initialization driver: driver_portMotorSonar_init_c_zero */,
/* 1 */  CALL(5)          /* Call initialization driver: driver_portFound_init_c_false */,
/* 2 */  CALL(7)          /* Call initialization driver: driver_portIntrusion_init_c_false */,
/* 3 */  CALL(9)          /* Call initialization driver: driver_portAngle_init_c_zero */,
/* 4 */  CALL(11)          /* Call initialization driver: driver_portDistance_init_c_zero */,
/* 5 */  CALL(13)          /* Call initialization driver: driver_portLightO_init_c_zero */,
/* 6 */  CALL(15)          /* Call initialization driver: driver_searchTask_statefound_init_c_false */,
/* 7 */  JUMP(8)          /* Jump to start mode: guard */,
/* 8 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 9 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 10 */  IF(0,11,12)          /* If actuator driver: condition_actMotorSonar_driverSonarMotor */,
/* 11 */  CALL(16)          /* Call actuator driver: driver_actMotorSonar_driverSonarMotor */,
/* 12 */  CALL(2)          /* Call actuator device driver: driver_actMotorSonar_c_set_motor_sonar_speed */,
/* 13 */  IF(1,14,16)          /* If mode driver: condition_search_driverGuardToSearch */,
/* 14 */  CALL(17)          /* Call mode driver: driver_search_driverGuardToSearch */,
/* 15 */  JUMP(104)          /*  Switch from mode: guard, unit: 0 to mode: search, unit: 0 */,
/* 16 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 17 */  IF(2,18,20)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 18 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 19 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 20 */  FUTURE(0,22,800)          /* Triggered jump to mode: guard, unit: 1 */,
/* 21 */  RETURN()          /* From mode: guard, unit: 0 */,
/* 22 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 23 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 24 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 25 */  IF(2,26,28)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 26 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 27 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 28 */  FUTURE(0,30,800)          /* Triggered jump to mode: guard, unit: 2 */,
/* 29 */  RETURN()          /* From mode: guard, unit: 1 */,
/* 30 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 31 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 32 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 33 */  IF(2,34,36)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 34 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 35 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 36 */  FUTURE(0,38,800)          /* Triggered jump to mode: guard, unit: 3 */,
/* 37 */  RETURN()          /* From mode: guard, unit: 2 */,
/* 38 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 39 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 40 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 41 */  IF(2,42,44)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 42 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 43 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 44 */  FUTURE(0,46,800)          /* Triggered jump to mode: guard, unit: 4 */,
/* 45 */  RETURN()          /* From mode: guard, unit: 3 */,
/* 46 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 47 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 48 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 49 */  IF(2,50,52)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 50 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 51 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 52 */  FUTURE(0,54,800)          /* Triggered jump to mode: guard, unit: 5 */,
/* 53 */  RETURN()          /* From mode: guard, unit: 4 */,
/* 54 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 55 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 56 */  IF(1,57,59)          /* If mode driver: condition_search_driverGuardToSearch */,
/* 57 */  CALL(17)          /* Call mode driver: driver_search_driverGuardToSearch */,
/* 58 */  JUMP(104)          /*  Switch from mode: guard, unit: 5 to mode: search, unit: 0 */,
/* 59 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 60 */  IF(2,61,63)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 61 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 62 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 63 */  FUTURE(0,65,800)          /* Triggered jump to mode: guard, unit: 6 */,
/* 64 */  RETURN()          /* From mode: guard, unit: 5 */,
/* 65 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 66 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 67 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 68 */  IF(2,69,71)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 69 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 70 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 71 */  FUTURE(0,73,800)          /* Triggered jump to mode: guard, unit: 7 */,
/* 72 */  RETURN()          /* From mode: guard, unit: 6 */,
/* 73 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 74 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 75 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 76 */  IF(2,77,79)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 77 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 78 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 79 */  FUTURE(0,81,800)          /* Triggered jump to mode: guard, unit: 8 */,
/* 80 */  RETURN()          /* From mode: guard, unit: 7 */,
/* 81 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 82 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 83 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 84 */  IF(2,85,87)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 85 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 86 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 87 */  FUTURE(0,89,800)          /* Triggered jump to mode: guard, unit: 9 */,
/* 88 */  RETURN()          /* From mode: guard, unit: 8 */,
/* 89 */  CALL(8)          /* Call output port copy driver: driver_portIntrusion_copy_c_bool for task: task_guardTask */,
/* 90 */  CALL(14)          /* Call output port copy driver: driver_portLightO_copy_c_int for task: task_guardTask */,
/* 91 */  CALL(0)          /* Call sensor device driver: driver_portLight_c_get_light_sensor */,
/* 92 */  IF(2,93,95)          /* If task driver: condition_guardTask_driverIntrusionStatus */,
/* 93 */  CALL(18)          /* Call task driver: driver_guardTask_driverIntrusionStatus */,
/* 94 */  SCHEDULE(0,0,3276800)       /* Schedule task: task_guardTask, release time: 0, relative deadline: 800 */,
/* 95 */  FUTURE(0,8,800)          /* Triggered jump to mode: guard, unit: 0 */,
/* 96 */  RETURN()          /* From mode: guard, unit: 9 */,
/* 97 */  CALL(6)          /* Call output port copy driver: driver_portFound_copy_c_bool for task: task_searchTask */,
/* 98 */  IF(0,99,100)          /* If actuator driver: condition_actMotorSonar_driverSonarMotor */,
/* 99 */  CALL(16)          /* Call actuator driver: driver_actMotorSonar_driverSonarMotor */,
/* 100 */  CALL(2)          /* Call actuator device driver: driver_actMotorSonar_c_set_motor_sonar_speed */,
/* 101 */  IF(3,102,104)          /* If mode driver: condition_guard_driverSearchToGuard */,
/* 102 */  CALL(19)          /* Call mode driver: driver_guard_driverSearchToGuard */,
/* 103 */  JUMP(16)          /*  Switch from mode: search, unit: 0 to mode: guard, unit: 0 */,
/* 104 */  IF(4,105,107)          /* If task driver: condition_searchTask_driverFoundStatus */,
/* 105 */  CALL(20)          /* Call task driver: driver_searchTask_driverFoundStatus */,
/* 106 */  SCHEDULE(1,0,32768000)       /* Schedule task: task_searchTask, release time: 0, relative deadline: 8000 */,
/* 107 */  FUTURE(0,97,8000)          /* Triggered jump to mode: search, unit: 0 */,
/* 108 */  RETURN()          /* From mode: search, unit: 0 */
};
